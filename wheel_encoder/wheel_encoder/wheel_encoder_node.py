#!usr/bin/python3

import os
import uuid
import yaml
import rclpy
# import tf_transformations
import transforms3d

from math import pi

from rclpy.node import Node
from std_msgs.msg import Header
from rclpy.parameter import Parameter
from tf2_ros import TransformBroadcaster
from rcl_interfaces.msg import SetParametersResult
from geometry_msgs.msg import (
    TransformStamped,
    Quaternion,
    Transform
)
from dt_interfaces_cps.msg import (
    WheelEncoderStamped,
    WheelsCmdStamped
)
from wheel_encoder import (
    WheelEncoderDriver,
    WheelDirection
)

class WheelEncoderNode(Node):
    """Node handling a single wheel encoder.
        This node is responsible for reading data off of a
        single wheel encoders. Robots with N wheels will need to spin N
        instances of this node. This node is compatible with any rotary encoder
        that signals ticks as rising edges on a digital GPIO pin.
        For now we use the `wheel_cmd_executed` to determine if we are moving
        forwards or backwards. As a result, if you manually push the robot,
        you will get potentially incorrect output (we default to always forward
        in this case).
        Subscribers:
           ~wheels_cmd_executed (:obj:`WheemsCmdStamped`):
                The actual commands executed
        Publishers:
           ~data (:obj:`WheelEncoderStamped`):
                Publishes the cumulative number of ticks generated by
                the encoder.
    """

    PUBLISH_FREQ_PARAM_NAME = "publish_frequency"

    def __init__(self, node_name: str):
        super().__init__(node_name)

        self._retrieve_parameters()
        self._load_custom_calibration()
        self.get_logger().debug(f"""
            _veh: {self._veh},
            _name: {self._name},
            _gpio_pin: {self._gpio_pin},
            _resolution: {self._resolution},
            _configuration: {self._configuration},
            _publish_frequency: {self._publish_frequency}
        """)

        self.create_publish_freq_param_callback()

        # Store number of ticks recorded by encoder
        self._tick = 0
        # publisher for wheel encoder ticks
        self._tick_pub = self.create_publisher(
            WheelEncoderStamped,
            "~/tick",
            1)
        
        # Subscriber for the wheel command executed
        self.sub_wheels = self.create_subscription(
            WheelsCmdStamped,
            "~/wheels_cmd_executed",
            self._wheels_cmd_executed_cb,
            1)
        
        # tf broadcaster for wheel frame
        self._tf_broadcaster = TransformBroadcaster(self)

        self._timer = self.create_timer(1.0/self._publish_frequency,
            self._cb_publish)

        self._driver = WheelEncoderDriver(self._gpio_pin, self._encoder_tick_cb)

    def _retrieve_parameters(self):
        self.declare_parameter("veh")
        self.declare_parameter("name")
        self.declare_parameter("param_file_path")
        self._veh = self.get_parameter("veh")\
            .get_parameter_value().string_value
        self._name = self.get_parameter("name")\
            .get_parameter_value().string_value
        param_file_path = self.get_parameter("param_file_path")\
            .get_parameter_value().string_value

        with open(param_file_path, 'r') as stream:
            config = yaml.safe_load(stream)
        self._gpio_pin = config["gpio"]
        self._resolution = config["resolution"]
        self._configuration = config["configuration"]
        self._publish_frequency = config["publish_frequency"]

    def create_publish_freq_param_callback(self):
        self.declare_parameter(
            WheelEncoderNode.PUBLISH_FREQ_PARAM_NAME, self._publish_frequency)
        publish_freq_param = rclpy.parameter.Parameter(
            WheelEncoderNode.PUBLISH_FREQ_PARAM_NAME,
            rclpy.Parameter.Type.INTEGER,
            self._publish_frequency
        )
        self.set_parameters([publish_freq_param])
        self.add_on_set_parameters_callback(self._parameters_callback)

    def _load_custom_calibration(self):
        calib_file = os.path.join(
            "/data/config/calibrations/encoder",
            f"{self._configuration}/{self._veh}.yaml")
        try:
            with open(calib_file, 'r') as f:
                calib_data = yaml.safe_load(f)
            
            custom_resolution = int(calib_data["resolution"])
            self._resolution = custom_resolution
            self.get_logger().info(f"""With calibration file: {calib_file},
                using custom encoder resolution: {self._resolution}""")

        except FileNotFoundError as _:
            self.get_logger().warn(f"""No custom encoder calibration found
                at: {calib_file}. Using default parameters.""")
        except KeyError as _:
            self.get_logger().warn(f"""No valid field 'resolution' found in
                encoder calibration file at: {calib_file}.
                Using default parameters.""")
        except ValueError as _:
            self.get_logger().warn(f"""No valid integer 'resolution' value found
                in encoder calibration file at: {calib_file}.
                Using default parameters.""")

    def _wheels_cmd_executed_cb(self, msg: WheelEncoderStamped):
        if self._configuration == "left":
            if msg.vel_left >= 0.0:
                self._driver.set_direction(WheelDirection.FORWARD)
            else:
                self._driver.set_direction(WheelDirection.REVERSE)
        elif self._configuration == "right":
            if msg.vel_right >= 0.0:
                self._driver.set_direction(WheelDirection.FORWARD)
            else:
                self._driver.set_direction(WheelDirection.REVERSE)

    def _encoder_tick_cb(self, tick_no):
        """
        Callback that receives new ticks from the encoder.
            Args:
                tick_no (int): cumulative total number of ticks
        """
        self._tick = tick_no

    def _cb_publish(self):
        header = Header()
        header.frame_id = f"{self._veh}/{self._name}_wheel_axis"
        header.stamp = self.get_clock().now().to_msg()

        # publish WheelEncoderStamped message
        self._tick_pub.publish(WheelEncoderStamped(
            header=header,
            data=self._tick,
            resolution=self._resolution,
            type=WheelEncoderStamped.ENCODER_TYPE_INCREMENTAL))

        # publish TF
        angle = (float(self._tick) / float(self._resolution)) * 2 * pi
        # quat = tf_transformations.quaternion_from_euler(0, angle, 0)
        quat = transforms3d.euler.euler2quat(0, angle, 0)
        self._tf_broadcaster.sendTransform(TransformStamped(
            header=header,
            child_frame_id=f"{self._veh}/{self._name}_wheel",
            transform=Transform(
                rotation=Quaternion(w=quat[0], x=quat[1], y=quat[2], z=quat[3]))
        ))

    def _parameters_callback(self, params):
        success = False
        for param in params:
            if param.name == WheelEncoderNode.PUBLISH_FREQ_PARAM_NAME:
                if param.type_ == Parameter.Type.INTEGER:
                    self._publish_frequency = param.value
                    success = True
                    self.get_logger().info(f"""Successfully set publish
                        frequency param to {self._publish_frequency}""")
        return SetParametersResult(successful=success)


def main(args=None):
    rclpy.init(args=args)
    rand = str(uuid.uuid4())[:8]
    node = WheelEncoderNode(f"wheel_encoder_{rand}")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
